// OFFIS Automation Framework
// Copyright (C) 2013 OFFIS e.V.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http:#www.gnu.org/licenses/>.

#include <QDebug>
#include <QCoreApplication>
#include <QFile>
#include <QTextStream>
#include <QStringList>
#include <QCryptographicHash>
#include <QDateTime>
#include <QFileInfo>
#include <QDir>

struct ID
{
    quint64 id1;
    quint64 id2;
};

struct Parameter
{
    QString name;
    QString type;
    bool isBasic;
    QString signature() const
    {
        if(isBasic)
            return QString("%1 %2").arg(type, name);
        else
            return QString("const %1& %2").arg(type, name);
    }
};

struct Method
{
    QString signature() const
    {
        QString sig;
        sig += name;
        sig += "(";
        QStringList paramSigs;
        foreach(const Parameter& param, params)
            paramSigs << param.signature();
        sig += paramSigs.join(", ");
        sig += ")";
        return sig;
    }
    QStringList paramNames() const {
        QStringList names;
        foreach(const Parameter& param, params)
            names << param.name;
        return names;
    }

    int id;
    bool isReverse;
    QString name;
    QList<Parameter> params;
};
quint64 createId(const QList<Method>& methods)
{
    quint64 numMethods = methods.size();
    quint64 numParams = 0;
    quint64 numChars = 0;
    foreach(const Method& method, methods)
    {
        numChars += method.signature().length();
        numParams += method.params.size();
    }
    quint64 part1 = 100000 * numMethods + numParams;
    part1 = part1 << 32;
    return part1 | numChars;
}

Method parseLine(const QString& line)
{
    QStringList basicTypes;
    basicTypes << "int" << "uint" << "short" << "ushort" << "char" << "uchar"
               << "long" << "ulong" << "quint64" << "qint64";
    static int id = 1;
    Method method;
    method.id = id++;
    int start = line.indexOf('(');
    int end = line.indexOf(')');
    method.name = line.mid(0, start);
    method.isReverse = false;
    if(method.name.startsWith('-'))
    {
        method.isReverse = true;
        method.name.remove(0,1);
    }
    QString paramsLine = line.mid(start+1, end-start-1);
    QStringList params = paramsLine.split(",", QString::SkipEmptyParts);
    foreach(QString param, params)
    {
        Parameter paramType;
        param = param.trimmed();
        if(param.isEmpty())
            continue;
        param.replace("unsigned long long", "quint64");
        param.replace("long long", "qint64");
        param.replace("unsigned ", "u");



        int split = param.indexOf(' ');
        paramType.name = param.mid(split+1).trimmed();
        paramType.type = param.mid(0, split).trimmed();
        paramType.isBasic = basicTypes.contains(paramType.type);
        method.params << paramType;
    }
    return method;
}

void writeMethod(QTextStream& stream, Method method, QString ns)
{
    stream << "void " << ns << method.signature() << endl;
    stream << "{" << endl;
    stream << "\tQByteArray msgData;" << endl;
    stream << "\tQDataStream stream(&msgData, QIODevice::WriteOnly);" << endl;
    stream << "\tstream << SignalProxy::gid1() << SignalProxy::gid2() << (int)" << QString::number(method.id) << ";" << endl;
    foreach(const Parameter& param, method.params)
        stream << "\tstream << " << param.name << ";" << endl;
    stream << "\ttransmitSignal(msgData);" << endl;
    stream << "}" << endl << endl;
}


void writeMethodParsing(QTextStream& stream, Method method)
{
    stream << "\tif(signalProxyMethodId == " << method.id << ") {" << endl;
    foreach(const Parameter& param, method.params)
        stream << "\t\t" << param.type << " " << param.name << ";" << endl;
    foreach(const Parameter& param, method.params)
        stream << "\t\tstream >> " << param.name << ";" << endl;
    stream << "\t\temit " << method.name << "(" << method.paramNames().join(", ") << ");" << endl;
    stream << "\t\treturn;" << endl;
    stream << "\t}" << endl;
}


void writeImplementation(ID id, const QList<Method>& methods, QDir dir, const QString& className, bool reverse)
{
    QString ns = className + "::";
    QFile file(dir.absoluteFilePath(QString("%1.cpp").arg(className)));
    file.open(QFile::WriteOnly);
    QTextStream stream(&file);
    stream << "//autogenerated file SignalProxy" << endl;
    //stream << "//created at:" << QDateTime::currentDateTime().toString() << endl << endl;
    stream << "#include \"" << className << ".h\"" << endl;
    stream << endl;
    stream << ns << className << "(QIODevice& readDevice, QIODevice& writeDevice)" << endl;
    stream << "\t: SignalProxy(Q_UINT64_C(0x" + QString::number(id.id1, 16) + "),Q_UINT64_C(0x" + QString::number(id.id2, 16) + "), readDevice, writeDevice)"  << endl;
    stream << "{}" << endl << endl;

    foreach(const Method& method, methods)
    {
        if(method.isReverse != reverse)
            writeMethod(stream, method, ns);
    }
    stream << "void " << ns << "processRemoteInputs(const QByteArray& data)" << endl;
    stream << "{" << endl;
    stream << "\tQDataStream stream(data);" << endl;
    stream << "\tquint64 signalProxyGid1 = 0;" << endl;
    stream << "\tquint64 signalProxyGid2 = 0;" << endl;
    stream << "\tint signalProxyMethodId = 0;" << endl;
    stream << "\tstream >> signalProxyGid1 >> signalProxyGid2 >> signalProxyMethodId;" << endl;
    stream << "\tSignalProxy::checkId(signalProxyGid1, signalProxyGid2);" << endl << endl;
    foreach(const Method& method, methods)
    {
        if(method.isReverse == reverse)
            writeMethodParsing(stream, method);
    }
    stream << endl;
    stream << "\tSignalProxy::handleError(signalProxyMethodId);" << endl;
    stream << "}" << endl;

}

void writeHeader(const QList<QString>& includes, const QList<Method>& methods, QDir dir, const QString& className, bool reverse)
{
    QFile file(dir.absoluteFilePath(QString("%1.h").arg(className)));
    file.open(QFile::WriteOnly);
    QTextStream stream(&file);
    stream << "//autogenerated file SignalProxy" << endl;
    //stream << "//created at:" << QDateTime::currentDateTime().toString() << endl << endl;
    stream << "#ifndef " << className.toUpper() << "_H" << endl;
    stream << "#define " << className.toUpper() << "_H" << endl << endl;
    stream << "#include \"SignalProxy.h\"" << endl;
    foreach(const QString& includeStr, includes)
        stream << "#include " << includeStr << endl;
    stream << endl;
    stream << "class " << className << " : public SignalProxy" << endl;
    stream << "{" << endl;
    stream << "\tQ_OBJECT" << endl;
    stream << "public:" << endl;
    stream << "\t" << className << "(QIODevice& readDevice, QIODevice& writeDevice);" << endl << endl;
    stream << "signals:" << endl;
    foreach(const Method& method, methods)
    {
        if(method.isReverse == reverse)
            stream << "\tvoid " << method.signature() << ";" << endl;
    }
    stream << endl;
    stream << "public slots:" << endl;
    foreach(const Method& method, methods)
    {
        if(method.isReverse != reverse)
            stream << "\tvoid " << method.signature() << ";" << endl;
    }
    stream << endl;
    stream << "private:" << endl;
    stream << "\tvoid processRemoteInputs(const QByteArray& data);" << endl;
    stream << "};" << endl << endl;
    stream << "#endif //" << className.toUpper() << "_H" << endl;

}
void writeClass(ID id, const QList<Method>& methods, const QList<QString>& includes, QDir dir, const QString& className, bool reverse)
{
    writeHeader(includes, methods, dir, className, reverse);
    writeImplementation(id, methods, dir, className, reverse);
}

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    QStringList args = a.arguments();
    if(args.size() < 3)
    {
        QTextStream(stdout) << "Usage: SignalProxy definitionFile codeTargetDir [--server-only|--client-only]" << endl;
        return 1;
    }
    QString definitionFile = args[1];
    QDir targetDir(args[2]);
    QStringList params;
    for(int i=3; i<args.size(); i++)
        params << args[i];

    QString className = QFileInfo(definitionFile).baseName();
    QFile file(definitionFile);
    file.open(QFile::ReadOnly);
    QTextStream stream(&file);
    QList<Method> methods;
    QList<QString> includes;
    QByteArray hashData;
    while(!stream.atEnd())
    {
        QString line = stream.readLine().trimmed();
        if(line.isEmpty() || line.startsWith('/'))
            continue;
        hashData.append(line.toLocal8Bit());
        if(line.startsWith("#include"))
        {
            line.replace("#include", "");
            includes << line.trimmed();
        }
        else
            methods << parseLine(line);

    }
    QByteArray hash = QCryptographicHash::hash(hashData, QCryptographicHash::Md5).toHex();
    ID id;
    id.id1 = hash.mid(0,15).toULongLong(0, 16);
    id.id2 = hash.mid(16).toULongLong(0, 16);
    qWarning() << "Found " << methods.size() << " methods. ID: 0x" << QString("0x%1%2").arg(id.id1, 16).arg(id.id2, 16);
    file.close();
    if(!params.contains("--server-only"))
        writeClass(id, methods, includes, targetDir, className + "Client", true);
    else if(!params.contains("--client-only"))
        writeClass(id, methods, includes, targetDir, className + "Server", false);
    QDir srcDir(a.applicationDirPath());
    QFile::copy(srcDir.absoluteFilePath("SignalProxy.h"), targetDir.absoluteFilePath("SignalProxy.h"));
    QFile::copy(srcDir.absoluteFilePath("SignalProxy.cpp"), targetDir.absoluteFilePath("SignalProxy.cpp"));
    return 0;
}


